[{"title":"My Experiences As An Backend Intern @ Amity","description":"A very brief summary of my intern experience.","content":"Amity is currently referred to 2 companies, Amity Solution and Amity Technology. I worked on Amity Technology, which sells SDK and UI-Kit that provide social media features for customers' applications. You can check out the details of their product at [their website](https://www.amity.co/social-cloud).\n\\\nBasically, we provide building blocks and some finished components for the customer to implement their own social media on their applications. So they don't need to build any infrastructure by themselves and can have their own social media that they can manage themselves (no need to abide by the rules of big social media like Facebook or Twitter anymore) \n## So how was my work?\nMy day-to-day work looks like this\n1. Team standup:  talked with the team about what have I done yesterday, what will I do today, do some code review, problem discussion, and normal conversation.\n2. Squad standup: short talk with **Project Manager** about what have I done, how the progress of each task and is there any blocker needs to be discussed, sprint planning, and sprint retro.\n3. Any other meetings necessary in between \n4. The remaining time is me working on the Jira ticket that I need to do.\n\n\nAnd the works I do are mainly\n1. Developing a new feature.\n2. Fixing any bugs that customers raised or we've found\n3. Technical debts work such as dependencies update, improving unit test \n4. Any other miscellaneous tasks e.g. prepare for knowledge sharing session \n### The new technology that I learned\n![tech](https://imgur.com/CeBkIAn.png)\nI have little experience writing a backend in JS/TS (express ü§£) and I still don't think it's a good choice to write backend in JS/TS because we don't have **REAL** types and the performance improvement is kinda hard (it's garbage collected and memory management is kind of not exist at all right?). \n\\\nYeah, everything at Amity is written in JS/TS ü§¶‚Äç‚ôÇÔ∏è. And I have learned so many things about JS ecosystem on backend side such as\n- [MoleculerJs](https://moleculer.services/index.html) which is a microservice framework that includes almost anything you want.  Our core system is mainly implemented on this framework.\n- [CRACO](https://craco.js.org/) (‡≤†_‡≤†), create-react-app-configuration-override an upgraded version of create-react-app which is super slow lol.\n\n\nAnd there are also other things \n- [MongoDB](https://www.mongodb.com/), our main database. I have learned how to index the database, design a proper data schema, different types of MongoDB collections/operations etc.\n- [Redis](https://redis.io/), our main cache. I have learned how to use it, and different types of data structures in it.\n- AWS Services e.g. [AWS Eventbridge scheduler](https://aws.amazon.com/eventbridge/scheduler/), [AWS Lambda](https://aws.amazon.com/lambda/), [AWS SQS](https://aws.amazon.com/sqs/)\n- [Serverless Framework](https://www.serverless.com/), we can use this to deploy AWS services programmatically.\n- [Kubernetes](https://kubernetes.io/), which our core system is deployed using it. I only learned about how to use [k9s](https://k9scli.io/) to see logs and check out each pod.\n### Developing a new feature\nHow is feature developed on Amity?. I'll only talk about it on the backend engineer side by explaining how I developed *Post Impression* feature (but only a fraction of it).  \n![impression](https://i.imgur.com/tRrEkcj.png)\nSo first we get the requirements of the feature that we need to do. For *Post Impression* feature, for example\n- Definition: impression is non-unique count of users who have viewed the post\n- When user view a post, post impression should increase\n- User should be able to view the impression value on post\n(note that in reality, the requirements are much more detailed than this)\n\n\nAnd then we need to propose a planned solution of how we should implement this feature on the current system (we called it tech-spec). This spec should describe what will need to be added, what needs to change, and wheter is there any new infrastructure. The spec should also be detailed as much as possible so the lead engineer and system architect can understand it completely and give a review. \n\n\\\nFor example, we will first draw the overall architecture diagram like the picture below and then explain what does each part do\n- User will need to first send a request to increase the post impression, then`moleculer service #1` will check for user's quota and send it to the `SQS #1`.\n- `moleculer service #2` will then poll a batch from the `SQS #1`, process the batch (check user's permission, etc.) and then send it to the next `SQS #2`.\n- The lambda will then poll a batch from the `SQS #2`, count the impression value and insert the unique view activity to a new MongoDB instance for this feature. Then it will call an internal API to update the impression value on core system.\n- `SQS #1` and `SQS #2` are used to make the load steady on `moleculer service #2` and the lambda. \nNote: This is a super simplified example (‚òûÔæü„ÉÆÔæü)‚òû\n\n![techspec](https://i.imgur.com/DJPYoEr.png)\n\nWhen the tech-spec is finished, we will start implementing which should be easy if the tech-spec is detailed enough and we don't encounter some weird problem. Then we do the testing (both by myself and QA team). If everything is okay, we will release it üéâ‚ú®\n\n### Some interesting problems\nThis section is about the problems that the backend team or I encounter and I found it interesting to talk about.\n##### Memory Leak\nYep, on one release suddenly the memory of production service exceeds a threshold and an alert is sent to the team. It was a disaster üòÇ, because no one knows how it happened. I didn't have a chance to be involved in fixing this issue that much but what I found is profiling a NodeJS application is hard as hell (or it's because we lack the skill to do it). When we have so many libraries that are in use at the same time, it's just too much information to filter. And JS/TS code is hard to be memory safe or efficient because the language is just not building for this use case.\n\n\\\nI think the main takeaway is, that if we use other languages like Rust, Go or Elixir this can still happen but fixing it should be much easier (especially on Rust because we can just look at the code). Well, I'm thinking about doing a comparison between these languages to check if this is true or not.\n##### Moleculer Serialization\n![moleculer](https://i.imgur.com/Vgpd254.png)\nI wasted like 2 days, confused about why I can't pass `Map` between services in moleculer (we use native JSON serializer). Remember this, you need to read the documents üòÇ.\n##### The config hell\nWith the help of tools like Serverless or Terraform, configuration is easier but we can still mess it up and some things still need to be manually edited. So, remember to recheck your configuration or you could possibly mess up the prod service (hopefully you have some automated check ü§∑‚Äç‚ôÇÔ∏è)\n## Conclusion (and some opinions)\nI've learned so much from working as a backend intern at Amity both the programming side and social side. My colleagues were all super nice and friendly, and the work is ok (I don't like JS/TS, so the work is not that fun ü§£), some takeaways that I can think of \n- Try to always learn about new technology so you can think of a wide variety of solutions.\n- Design a system that will work with the smallest cost (both money and time) as possible. Also, try to measure the load that the system is expected to take what could went wrong when designing a system for an unknown load ü§∑‚Äç‚ôÇÔ∏è.\n- Surprising thing: you don't need to have a computer science/engineer background to work as a QA or Engineer.\n- Team's proficiency needs to be considered when choosing the tech stack (but I also think that there's a threshold that we need to move on to better tech e.g. ditch the JS)","htmlContent":"<p>Amity is currently referred to 2 companies, Amity Solution and Amity Technology. I worked on Amity Technology, which sells SDK and UI-Kit that provide social media features for customers' applications. You can check out the details of their product at <a href=\"https://www.amity.co/social-cloud\">their website</a>.<br>\n<br>\nBasically, we provide building blocks and some finished components for the customer to implement their own social media on their applications. So they don't need to build any infrastructure by themselves and can have their own social media that they can manage themselves (no need to abide by the rules of big social media like Facebook or Twitter anymore)</p>\n<h2>So how was my work?</h2>\n<p>My day-to-day work looks like this</p>\n<ol>\n<li>Team standup:  talked with the team about what have I done yesterday, what will I do today, do some code review, problem discussion, and normal conversation.</li>\n<li>Squad standup: short talk with <strong>Project Manager</strong> about what have I done, how the progress of each task and is there any blocker needs to be discussed, sprint planning, and sprint retro.</li>\n<li>Any other meetings necessary in between</li>\n<li>The remaining time is me working on the Jira ticket that I need to do.</li>\n</ol>\n<p>And the works I do are mainly</p>\n<ol>\n<li>Developing a new feature.</li>\n<li>Fixing any bugs that customers raised or we've found</li>\n<li>Technical debts work such as dependencies update, improving unit test</li>\n<li>Any other miscellaneous tasks e.g. prepare for knowledge sharing session</li>\n</ol>\n<h3>The new technology that I learned</h3>\n<p><img src=\"https://imgur.com/CeBkIAn.png\" alt=\"tech\"><br>\nI have little experience writing a backend in JS/TS (express ü§£) and I still don't think it's a good choice to write backend in JS/TS because we don't have <strong>REAL</strong> types and the performance improvement is kinda hard (it's garbage collected and memory management is kind of not exist at all right?).<br>\n<br>\nYeah, everything at Amity is written in JS/TS ü§¶‚Äç‚ôÇÔ∏è. And I have learned so many things about JS ecosystem on backend side such as</p>\n<ul>\n<li><a href=\"https://moleculer.services/index.html\">MoleculerJs</a> which is a microservice framework that includes almost anything you want.  Our core system is mainly implemented on this framework.</li>\n<li><a href=\"https://craco.js.org/\">CRACO</a> (‡≤†_‡≤†), create-react-app-configuration-override an upgraded version of create-react-app which is super slow lol.</li>\n</ul>\n<p>And there are also other things</p>\n<ul>\n<li><a href=\"https://www.mongodb.com/\">MongoDB</a>, our main database. I have learned how to index the database, design a proper data schema, different types of MongoDB collections/operations etc.</li>\n<li><a href=\"https://redis.io/\">Redis</a>, our main cache. I have learned how to use it, and different types of data structures in it.</li>\n<li>AWS Services e.g. <a href=\"https://aws.amazon.com/eventbridge/scheduler/\">AWS Eventbridge scheduler</a>, <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a>, <a href=\"https://aws.amazon.com/sqs/\">AWS SQS</a></li>\n<li><a href=\"https://www.serverless.com/\">Serverless Framework</a>, we can use this to deploy AWS services programmatically.</li>\n<li><a href=\"https://kubernetes.io/\">Kubernetes</a>, which our core system is deployed using it. I only learned about how to use <a href=\"https://k9scli.io/\">k9s</a> to see logs and check out each pod.</li>\n</ul>\n<h3>Developing a new feature</h3>\n<p>How is feature developed on Amity?. I'll only talk about it on the backend engineer side by explaining how I developed <em>Post Impression</em> feature (but only a fraction of it).<br>\n<img src=\"https://i.imgur.com/tRrEkcj.png\" alt=\"impression\"><br>\nSo first we get the requirements of the feature that we need to do. For <em>Post Impression</em> feature, for example</p>\n<ul>\n<li>Definition: impression is non-unique count of users who have viewed the post</li>\n<li>When user view a post, post impression should increase</li>\n<li>User should be able to view the impression value on post<br>\n(note that in reality, the requirements are much more detailed than this)</li>\n</ul>\n<p>And then we need to propose a planned solution of how we should implement this feature on the current system (we called it tech-spec). This spec should describe what will need to be added, what needs to change, and wheter is there any new infrastructure. The spec should also be detailed as much as possible so the lead engineer and system architect can understand it completely and give a review.</p>\n<p><br>\nFor example, we will first draw the overall architecture diagram like the picture below and then explain what does each part do</p>\n<ul>\n<li>User will need to first send a request to increase the post impression, then<code>moleculer service #1</code> will check for user's quota and send it to the <code>SQS #1</code>.</li>\n<li><code>moleculer service #2</code> will then poll a batch from the <code>SQS #1</code>, process the batch (check user's permission, etc.) and then send it to the next <code>SQS #2</code>.</li>\n<li>The lambda will then poll a batch from the <code>SQS #2</code>, count the impression value and insert the unique view activity to a new MongoDB instance for this feature. Then it will call an internal API to update the impression value on core system.</li>\n<li><code>SQS #1</code> and <code>SQS #2</code> are used to make the load steady on <code>moleculer service #2</code> and the lambda.<br>\nNote: This is a super simplified example (‚òûÔæü„ÉÆÔæü)‚òû</li>\n</ul>\n<p><img src=\"https://i.imgur.com/DJPYoEr.png\" alt=\"techspec\"></p>\n<p>When the tech-spec is finished, we will start implementing which should be easy if the tech-spec is detailed enough and we don't encounter some weird problem. Then we do the testing (both by myself and QA team). If everything is okay, we will release it üéâ‚ú®</p>\n<h3>Some interesting problems</h3>\n<p>This section is about the problems that the backend team or I encounter and I found it interesting to talk about.</p>\n<h5>Memory Leak</h5>\n<p>Yep, on one release suddenly the memory of production service exceeds a threshold and an alert is sent to the team. It was a disaster üòÇ, because no one knows how it happened. I didn't have a chance to be involved in fixing this issue that much but what I found is profiling a NodeJS application is hard as hell (or it's because we lack the skill to do it). When we have so many libraries that are in use at the same time, it's just too much information to filter. And JS/TS code is hard to be memory safe or efficient because the language is just not building for this use case.</p>\n<p><br>\nI think the main takeaway is, that if we use other languages like Rust, Go or Elixir this can still happen but fixing it should be much easier (especially on Rust because we can just look at the code). Well, I'm thinking about doing a comparison between these languages to check if this is true or not.</p>\n<h5>Moleculer Serialization</h5>\n<p><img src=\"https://i.imgur.com/Vgpd254.png\" alt=\"moleculer\"><br>\nI wasted like 2 days, confused about why I can't pass <code>Map</code> between services in moleculer (we use native JSON serializer). Remember this, you need to read the documents üòÇ.</p>\n<h5>The config hell</h5>\n<p>With the help of tools like Serverless or Terraform, configuration is easier but we can still mess it up and some things still need to be manually edited. So, remember to recheck your configuration or you could possibly mess up the prod service (hopefully you have some automated check ü§∑‚Äç‚ôÇÔ∏è)</p>\n<h2>Conclusion (and some opinions)</h2>\n<p>I've learned so much from working as a backend intern at Amity both the programming side and social side. My colleagues were all super nice and friendly, and the work is ok (I don't like JS/TS, so the work is not that fun ü§£), some takeaways that I can think of</p>\n<ul>\n<li>Try to always learn about new technology so you can think of a wide variety of solutions.</li>\n<li>Design a system that will work with the smallest cost (both money and time) as possible. Also, try to measure the load that the system is expected to take what could went wrong when designing a system for an unknown load ü§∑‚Äç‚ôÇÔ∏è.</li>\n<li>Surprising thing: you don't need to have a computer science/engineer background to work as a QA or Engineer.</li>\n<li>Team's proficiency needs to be considered when choosing the tech stack (but I also think that there's a threshold that we need to move on to better tech e.g. ditch the JS)</li>\n</ul>\n","slug":"my-experiences-as-an-backend-intern-@-amity","createdAt":"2023-11-04T15:18:07.118Z","updatedAt":"2023-11-05T18:02:13.301Z"},{"title":"Changing from Strapi to my owm CMS.","description":"How I implement my own CMS and why I do it.","content":"In this blog, I'll tell you how I build my own CMS to manage my contents on this website. \n\n## Why not use Strapi?\nFirst of all, why not just use Strapi? Strapi is a great CMS, but we only manage a few simple contents like blog markdown and information on my work. So, using Strapi seems to be overengineering, and I can save my money by not hosting Strapi. \n\n## What do I need in my CMS?\nOverall, I want a Strapi-like UI for managing my blogs and works. It should look something like this.\n\\\n*Overall UI, left side is a navigation tab and right side is a page*\n![overall](https://i.imgur.com/zwgOfw5.png) *Create/Edit blog UI.*\n![create](https://i.imgur.com/dtAOtrc.png)\n\nAnd I don't want to host it, so I'll only use development server to run this web and push changes to Github after our contents have been handled.\n\\\nI'll be using YAML files as a database because we can easily manage YAML files by using this package [js-yaml](https://www.npmjs.com/package/js-yaml). Other options might be SQLite or MySQL. So we also need a backend code using `js-yaml` package to manage my database.\n\n\n## How do I build my own CMS?\nBefore we build anything, let's set up [SvelteKit](https://kit.svelte.dev/) project first.\nI run `npm init svelte .` in `admin/` folder and use all options in the image below. \n![svelte options](https://i.imgur.com/OUNjS9f.png)\n### Backend \nNext, let's create our backend. I want 2 types of data schema for blog and work.\n\\\n**Blog Data Schema**\n`BlogContent` interface will be our input and `Blog` will be our object to save on our database.\n```ts\n// admin/src/lib/blog.ts\nexport interface BlogContent extends JSONObject {\n\ttitle: string;\n\tdescription: string;\n\tcontent: string;\n}\n\nexport interface Blog extends BlogContent {\n\thtmlContent: string;\n\tslug: string;\n\tcreatedAt: string;\n\tupdatedAt: string;\n}\n```\n\\\n**Work Data Schema**\nSame with the Blog Data Scheme, `WorkContent` will be our input and `Work` will be our object to save on our database.\n```ts\n// admin/src/lib/work_manager.ts\nexport interface Link extends JSONObject {\n\thref: string;\n\ttext: string;\n}\n\nexport interface WorkContent extends JSONObject {\n\ttitle: string;\n\ttags: string[];\n\tlinks: Link[];\n\tbody: string;\n\t}\n\nexport interface Work extends WorkContent {\n\tid: number;\n}\n```\nAnd now we need a backend code to manage these data schemas. First, I'll write some tests for our backend code.\n\\\n**Backend Testing & Development**\nI'll use [Jest](https://jestjs.io/) to test our backend code. First install it via `npm install -D jest ts-jest @types/jest` and in  `package.json` add jest configuration for `ts` using `ts-jest` and [ECMAScript Modules](https://jestjs.io/docs/ecmascript-modules) configuration.\n```json\n// admin/package.json\n{\n\t...,\n\t\"jest\": {\n\t\t\"testEnvironment\": \"node\",\n\t\t\"transform\": {\n\t\t\t\"\\\\.[jt]sx?$\": \"ts-jest\"\n\t\t},\n\t\t\"preset\": \"ts-jest/presets/default-esm\",\n\t\t\"globals\": {\n\t\t\t\"ts-jest\": {\n\t\t\t\t\"useESM\": true\n\t\t\t}\n\t\t},\n\t\t\"moduleNameMapper\": {\n\t\t\t\"^(\\\\.{1,2}/.*)\\\\.js$\": \"$1\"\n\t\t}\n\t},\n\t\"scripts\": {\n\t\t...,\n\t\t\"jest\": \"node --experimental-vm-modules node_modules/jest/bin/jest.js ./src\",\n\t},\n}\n```\nIn our backend, we should be able to add, edit, delete and get from our database and these methods should be in our data structure class `BlogManager` and `WorkManager`. So we need to write a test for these methods.\n\\\nAn example of my test cases.\n```ts\n// admin/src/lib/blog.test.ts\nconst path = './tests/data/blogs';\nconst bm = new BlogManager(path);\n\ntest('Can add new blog?', () => {\n\tconst title = 'test add';\n\tconst blog: BlogContent = {\n\t\ttitle,\n\t\tdescription: 'test blog',\n\t\tcontent: 'Lorem .....'\n\t};\n\tconst ret = bm.add(blog);\n\texpect(ret).toEqual(true);\n\t// file name is a slug of title\n\tconst resultPath = `${path}/test-add.yaml`;\n\tconst result = yaml.load(readFileSync(resultPath, 'utf-8')) as BlogContent;\n\texpect(result).toBeDefined();\n\texpect(result.title).toEqual(blog.title);\n\texpect(result.description).toEqual(blog.description);\n\texpect(result.content).toEqual(blog.content);\n\t// remove that blog after done testing\n\tif (existsSync(resultPath)) unlinkSync(resultPath);\n});\n```\n\\\nAnd let's implement `BlogManager` class that will pass this test case.\n```ts\n// admin/src/lib/blog.ts\nexport default class BlogManager {\n\tpath: string;\n\t\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t}\n\t\n\tstatic slug(title: string): string {\n\t\treturn title\n\t\t.toLowerCase()\n\t\t.trim()\n\t\t.replace(/ /g, '-')\n\t\t.replace(/[.\\\\/:*?\"<>|]/g, '');\n\t}\n\n\tadd(blog: BlogContent): boolean {\n\t\tconst slug = BlogManager.slug(blog.title);\n\t\tconst path = `${this.path}/${slug}.yaml`;\n\t\tif (!existsSync(path)) {\n\t\t\tconst date = new Date().toISOString();\n\t\t\tconst data = blog as Blog;\n\t\t\tdata.htmlContent = md(blog.content);\n\t\t\tdata.slug = slug;\n\t\t\tdata.createdAt = date;\n\t\t\tdata.updatedAt = date;\n\t\t\twriteFileSync(path, yaml.dump(data));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\nFor `WorkManager` and other methods, the development process is the same as above. You can see all the codes on [admin/src/lib](https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/lib).\n\\\n**API Routes**\nNow, I need to create an API that our frontend web can use because we can't use `BlogManager` and `WorkManager` class directly on SvelteKit page. In SvelteKit, we can create our API by using [Standalone endpoints](https://kit.svelte.dev/docs/routing#endpoints-standalone-endpoints)\n\\\nTherefore, we will use `BlogManager` and `WorkManager` class to create our REST API. Where our endpoints `request` will contain any information necessary for our data structure class.\n\\\nAn example of my endpoints. For full source code, you can visit [admin/src/routes/api](https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/routes/api).\n```ts\n// admin/src/routes/api/post.ts\nconst bm = new BlogManager('../src/data/blogs');\n\nexport const post: RequestHandler = async ({ request }) => {\n\tconst data = (await request.json()) as BlogContent;\n\tif (bm.add(data)) return { status: 200 };\n\t\treturn { status: 500 };\n};\n...\n```\n\n### Frontend\nLastly, let's create our frontend using [SMUI](https://sveltematerialui.com/) and [tailwindcss](https://tailwindcss.com/). \n\\\nSetting up SMUI can be done by following this [guide](https://sveltematerialui.com/SVELTEKIT.md) (I wish this could be simpler) and setting up tailwindcss by following this [guide](https://tailwindcss.com/docs/guides/sveltekit) but in `app.css` only add `@tailwind components` and `@tailwind utilities` because `@tailwind base` will override some of SMUI styling.\n\\\n**Overview**\nAfter all the setup, I need to create all of [SvelteKit Pages](https://kit.svelte.dev/docs/routing#pages) that we will need.\n\nThis is a list of svelte files on `admin/src/routes` for all of our pages.\n```\nPS>> tree /f\n‚îÇ   index.svelte\n‚îÇ   __layout.svelte\n‚îÇ\n‚îú‚îÄ‚îÄ‚îÄblog\n‚îÇ   ‚îÇ   create.svelte\n‚îÇ   ‚îÇ   index.svelte\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ‚îÄedit\n‚îÇ           [slug].svelte\n‚îÇ\n‚îî‚îÄ‚îÄ‚îÄworks\n    ‚îÇ   create.svelte\n    ‚îÇ   index.svelte\n    ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄedit\n            [id].svelte\n```\n\n`__layout.svelte` is a file that will contain our layout for every page. (You can read more on [SvelteKit Doc](https://kit.svelte.dev/docs/layouts)). So our navigation between 2 of content types will be here and it'll look like the image below.\n![overall](https://i.imgur.com/zwgOfw5.png)\nBoth `blog` and `works` routes are similar because they need to have these nested routes.\n- `index` is a page that will show us a list of our contents and some buttons to manage those contents. It'll look like the right side of a picture in *What I need in my CMS?* section.\n\t![data table](https://i.imgur.com/m4qcIlX.png)\n- `create` and `edit/[some identifier]` is a page that will show us what information we need to provide to that content type. It'll look like the picture in *What I need in my CMS?* section too. ![create](https://i.imgur.com/dtAOtrc.png)\n\n**Implementation**\nFirst,  `__layout.svelte` is a simple svelte component with a few SMUI components inside it, nothing interesting.\n\\\nNext, `index.svelte` will contain [SMUI Data Table](https://sveltematerialui.com/demo/data-table/) with data from our API by using [SvelteKit Loading](https://kit.svelte.dev/docs/loading) by below code (blog route example).\n```ts\n<script lang=\"ts\" context=\"module\">\n\timport type { Load } from '@sveltejs/kit';\n\timport type { Blog } from '$lib/blog';\n\n\texport const load: Load = async ({ fetch }) => {\n\t\tconst resp = await fetch('/api/post');\n\t\tconst posts = (await resp.json()) as Blog[];\n\t\treturn { props: { posts } };\n\t};\n</script>\n```\nLast, let's look at how I implement `create.svelte` and `edit/[slug].svelte` of blog route. Both of these pages will contain the same component `Blogcard` that will has properties of `type Blog`. `Blogcard` will provide us with data visualization and input forms. \n\\\nSo in `create.svelte`, we will have an empty `Blogcard` that we need to fill the forms and we can save those data by fetching our API (below code).\n```ts\n<script lang=\"ts\">\n\timport { goto } from '$app/navigation';\n\timport type { BlogContent } from '$lib/blog';\n\timport Blogcard from '$lib/components/blogcard.svelte';\n\n\tconst handleSave = async (event: any) => {\n\t\tconst blogpost = event.detail.blogpost as BlogContent;\n\t\tconst res = await fetch('/api/post', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify(blogpost)\n\t\t});\n\t\tif (res.status === 200) {\n\t\t\tgoto(`/blog/edit/${event.detail.slug}`);\n\t\t}\n\t};\n</script>\n<Blogcard on:save={handleSave} />\n```\nDid you see something interesting? On `<Blogcard on:save={handleSave} />`, what is `on:save={handleSave}`?. It's a [Svelte Event Forwarding](https://svelte.dev/tutorial/event-forwarding) mechanism. By using the below code on `Blogcard` component, we can handle `Blogcard` save button behavior on an upper component.\n```ts\nconst dispatch = createEventDispatcher();\nconst onSave = async () => {\n\tif (filled) { // check if forms if filled\n\t\tconst blogpost: BlogContent = {\n\t\t\ttitle,\n\t\t\tdescription,\n\t\t\tcontent\n\t\t};\n\t\tdispatch('save', { blogpost, slug }); // dispatch event data\n\t}\n};\n```\nNow, in `edit/[slug].svelte` there is significant only one changes from `create.svelte`. \n\\\nWe are using square brackets on Svelte component file. This is a SvelteKit dynamic parameters.\n> From [SvelteKit Doc](https://kit.svelte.dev/docs/routing#pages)\n> Dynamic parameters are encoded using¬†`[brackets]`. For example, a blog post might be defined by¬†`src/routes/blog/[slug].svelte`. These parameters can be accessed in a¬†[`load`](https://kit.svelte.dev/docs/loading#input-params)¬†function or via the¬†[`page`](https://kit.svelte.dev/docs/modules#$app-stores)¬†store.\n\nNow we can use dynamic parameters to fetch our blog content that we want to edit and show it on `Blogcard` by providing its properties with fetched blog content. We can use [Svelte Spread Props](https://svelte.dev/tutorial/spread-props) for more compact code too.\n \\\n *Above paragraph in code.*\n```ts\n<script lang=\"ts\" context=\"module\">\n\timport type { Load } from '@sveltejs/kit';\n\timport type { Blog, BlogContent } from '$lib/blog';\n\n\texport const load: Load = async ({ fetch, params }) => {\n\t\tconst resp = await fetch(`/api/post?slug=${params.slug}`);\n\t\tconst post = (await resp.json()) as Blog;\n\t\treturn { props: { post } };\n\t};\n</script>\n\n<script lang=\"ts\">\n\texport let post: Blog;\n</script>\n\n<Blogcard {...post} on:save={handleSave} />\n```\nFor `works` route the implementation is the same as `blog` route. You can view all source code on [TanatBlog](https://github.com/RiwEZ/TanatBlog) repo.\n\n### Conclusion\nYeyyy! I finished creating my own CMS for my blog. We have learned how to create basic [SvelteKit](https://kit.svelte.dev/) web-app with [SMUI](https://sveltematerialui.com/) and [tailwindcss](https://tailwindcss.com/) and using [Jest](https://jestjs.io/) to test backend too. If you have any question please comment below or [contact me](/TanatBlog/contact), and be sure to check [TanatBlog](https://github.com/RiwEZ/TanatBlog) repo.\n\n> This project was fun, but it took way too many times for me üòÖ. Hope this blog will help others do similar project faster!!!","htmlContent":"<p>In this blog, I'll tell you how I build my own CMS to manage my contents on this website.</p>\n<h2>Why not use Strapi?</h2>\n<p>First of all, why not just use Strapi? Strapi is a great CMS, but we only manage a few simple contents like blog markdown and information on my work. So, using Strapi seems to be overengineering, and I can save my money by not hosting Strapi.</p>\n<h2>What do I need in my CMS?</h2>\n<p>Overall, I want a Strapi-like UI for managing my blogs and works. It should look something like this.<br>\n<br>\n<em>Overall UI, left side is a navigation tab and right side is a page</em><br>\n<img src=\"https://i.imgur.com/zwgOfw5.png\" alt=\"overall\"> <em>Create/Edit blog UI.</em><br>\n<img src=\"https://i.imgur.com/dtAOtrc.png\" alt=\"create\"></p>\n<p>And I don't want to host it, so I'll only use development server to run this web and push changes to Github after our contents have been handled.<br>\n<br>\nI'll be using YAML files as a database because we can easily manage YAML files by using this package <a href=\"https://www.npmjs.com/package/js-yaml\">js-yaml</a>. Other options might be SQLite or MySQL. So we also need a backend code using <code>js-yaml</code> package to manage my database.</p>\n<h2>How do I build my own CMS?</h2>\n<p>Before we build anything, let's set up <a href=\"https://kit.svelte.dev/\">SvelteKit</a> project first.<br>\nI run <code>npm init svelte .</code> in <code>admin/</code> folder and use all options in the image below.<br>\n<img src=\"https://i.imgur.com/OUNjS9f.png\" alt=\"svelte options\"></p>\n<h3>Backend</h3>\n<p>Next, let's create our backend. I want 2 types of data schema for blog and work.<br>\n<br>\n<strong>Blog Data Schema</strong><br>\n<code>BlogContent</code> interface will be our input and <code>Blog</code> will be our object to save on our database.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">BlogContent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Blog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BlogContent</span> {\n\t<span class=\"hljs-attr\">htmlContent</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">slug</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">createdAt</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">updatedAt</span>: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p><br>\n<strong>Work Data Schema</strong><br>\nSame with the Blog Data Scheme, <code>WorkContent</code> will be our input and <code>Work</code> will be our object to save on our database.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/work_manager.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Link</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">href</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">WorkContent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">tags</span>: <span class=\"hljs-built_in\">string</span>[];\n\t<span class=\"hljs-attr\">links</span>: <span class=\"hljs-title class_\">Link</span>[];\n\t<span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">string</span>;\n\t}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Work</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">WorkContent</span> {\n\t<span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p>And now we need a backend code to manage these data schemas. First, I'll write some tests for our backend code.<br>\n<br>\n<strong>Backend Testing &amp; Development</strong><br>\nI'll use <a href=\"https://jestjs.io/\">Jest</a> to test our backend code. First install it via <code>npm install -D jest ts-jest @types/jest</code> and in  <code>package.json</code> add jest configuration for <code>ts</code> using <code>ts-jest</code> and <a href=\"https://jestjs.io/docs/ecmascript-modules\">ECMAScript Modules</a> configuration.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/package.json</span>\n<span class=\"hljs-punctuation\">{</span>\n\t...<span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-attr\">&quot;jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t<span class=\"hljs-attr\">&quot;testEnvironment&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;transform&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;\\\\.[jt]sx?$&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;ts-jest&quot;</span>\n\t\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;preset&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;ts-jest/presets/default-esm&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;globals&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;ts-jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t\t<span class=\"hljs-attr\">&quot;useESM&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\n\t\t\t<span class=\"hljs-punctuation\">}</span>\n\t\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;moduleNameMapper&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;^(\\\\.{1,2}/.*)\\\\.js$&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;$1&quot;</span>\n\t\t<span class=\"hljs-punctuation\">}</span>\n\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t...<span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node --experimental-vm-modules node_modules/jest/bin/jest.js ./src&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>In our backend, we should be able to add, edit, delete and get from our database and these methods should be in our data structure class <code>BlogManager</code> and <code>WorkManager</code>. So we need to write a test for these methods.<br>\n<br>\nAn example of my test cases.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.test.ts</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-string\">&#x27;./tests/data/blogs&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> bm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BlogManager</span>(path);\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;Can add new blog?&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-string\">&#x27;test add&#x27;</span>;\n\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">blog</span>: <span class=\"hljs-title class_\">BlogContent</span> = {\n\t\ttitle,\n\t\t<span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&#x27;test blog&#x27;</span>,\n\t\t<span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">&#x27;Lorem .....&#x27;</span>\n\t};\n\t<span class=\"hljs-keyword\">const</span> ret = bm.<span class=\"hljs-title function_\">add</span>(blog);\n\t<span class=\"hljs-title function_\">expect</span>(ret).<span class=\"hljs-title function_\">toEqual</span>(<span class=\"hljs-literal\">true</span>);\n\t<span class=\"hljs-comment\">// file name is a slug of title</span>\n\t<span class=\"hljs-keyword\">const</span> resultPath = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${path}</span>/test-add.yaml`</span>;\n\t<span class=\"hljs-keyword\">const</span> result = yaml.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-title function_\">readFileSync</span>(resultPath, <span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t<span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toBeDefined</span>();\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">title</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">title</span>);\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">description</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">description</span>);\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">content</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">content</span>);\n\t<span class=\"hljs-comment\">// remove that blog after done testing</span>\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">existsSync</span>(resultPath)) <span class=\"hljs-title function_\">unlinkSync</span>(resultPath);\n});\n</code></pre>\n<p><br>\nAnd let's implement <code>BlogManager</code> class that will pass this test case.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BlogManager</span> {\n\t<span class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\">string</span>;\n\t\n\t<span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">path: <span class=\"hljs-built_in\">string</span></span>) {\n\t\t<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">path</span> = path;\n\t}\n\t\n\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">slug</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-built_in\">string</span> {\n\t\t<span class=\"hljs-keyword\">return</span> title\n\t\t.<span class=\"hljs-title function_\">toLowerCase</span>()\n\t\t.<span class=\"hljs-title function_\">trim</span>()\n\t\t.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/ /g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>)\n\t\t.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[.\\\\/:*?&quot;&lt;&gt;|]/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>);\n\t}\n\n\t<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-attr\">blog</span>: <span class=\"hljs-title class_\">BlogContent</span>): <span class=\"hljs-built_in\">boolean</span> {\n\t\t<span class=\"hljs-keyword\">const</span> slug = <span class=\"hljs-title class_\">BlogManager</span>.<span class=\"hljs-title function_\">slug</span>(blog.<span class=\"hljs-property\">title</span>);\n\t\t<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.path}</span>/<span class=\"hljs-subst\">${slug}</span>.yaml`</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">existsSync</span>(path)) {\n\t\t\t<span class=\"hljs-keyword\">const</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toISOString</span>();\n\t\t\t<span class=\"hljs-keyword\">const</span> data = blog <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>;\n\t\t\tdata.<span class=\"hljs-property\">htmlContent</span> = <span class=\"hljs-title function_\">md</span>(blog.<span class=\"hljs-property\">content</span>);\n\t\t\tdata.<span class=\"hljs-property\">slug</span> = slug;\n\t\t\tdata.<span class=\"hljs-property\">createdAt</span> = date;\n\t\t\tdata.<span class=\"hljs-property\">updatedAt</span> = date;\n\t\t\t<span class=\"hljs-title function_\">writeFileSync</span>(path, yaml.<span class=\"hljs-title function_\">dump</span>(data));\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\t}\n}\n</code></pre>\n<p>For <code>WorkManager</code> and other methods, the development process is the same as above. You can see all the codes on <a href=\"https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/lib\">admin/src/lib</a>.<br>\n<br>\n<strong>API Routes</strong><br>\nNow, I need to create an API that our frontend web can use because we can't use <code>BlogManager</code> and <code>WorkManager</code> class directly on SvelteKit page. In SvelteKit, we can create our API by using <a href=\"https://kit.svelte.dev/docs/routing#endpoints-standalone-endpoints\">Standalone endpoints</a><br>\n<br>\nTherefore, we will use <code>BlogManager</code> and <code>WorkManager</code> class to create our REST API. Where our endpoints <code>request</code> will contain any information necessary for our data structure class.<br>\n<br>\nAn example of my endpoints. For full source code, you can visit <a href=\"https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/routes/api\">admin/src/routes/api</a>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/routes/api/post.ts</span>\n<span class=\"hljs-keyword\">const</span> bm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BlogManager</span>(<span class=\"hljs-string\">&#x27;../src/data/blogs&#x27;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">post</span>: <span class=\"hljs-title class_\">RequestHandler</span> = <span class=\"hljs-keyword\">async</span> ({ request }) =&gt; {\n\t<span class=\"hljs-keyword\">const</span> data = (<span class=\"hljs-keyword\">await</span> request.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t<span class=\"hljs-keyword\">if</span> (bm.<span class=\"hljs-title function_\">add</span>(data)) <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">200</span> };\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">500</span> };\n};\n...\n</code></pre>\n<h3>Frontend</h3>\n<p>Lastly, let's create our frontend using <a href=\"https://sveltematerialui.com/\">SMUI</a> and <a href=\"https://tailwindcss.com/\">tailwindcss</a>.<br>\n<br>\nSetting up SMUI can be done by following this <a href=\"https://sveltematerialui.com/SVELTEKIT.md\">guide</a> (I wish this could be simpler) and setting up tailwindcss by following this <a href=\"https://tailwindcss.com/docs/guides/sveltekit\">guide</a> but in <code>app.css</code> only add <code>@tailwind components</code> and <code>@tailwind utilities</code> because <code>@tailwind base</code> will override some of SMUI styling.<br>\n<br>\n<strong>Overview</strong><br>\nAfter all the setup, I need to create all of <a href=\"https://kit.svelte.dev/docs/routing#pages\">SvelteKit Pages</a> that we will need.</p>\n<p>This is a list of svelte files on <code>admin/src/routes</code> for all of our pages.</p>\n<pre class=\"hljs\"><code>PS&gt;&gt; tree /f\n‚îÇ   index.svelte\n‚îÇ   __layout.svelte\n‚îÇ\n‚îú‚îÄ‚îÄ‚îÄblog\n‚îÇ   ‚îÇ   create.svelte\n‚îÇ   ‚îÇ   index.svelte\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ‚îÄedit\n‚îÇ           [slug].svelte\n‚îÇ\n‚îî‚îÄ‚îÄ‚îÄworks\n    ‚îÇ   create.svelte\n    ‚îÇ   index.svelte\n    ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄedit\n            [id].svelte\n</code></pre>\n<p><code>__layout.svelte</code> is a file that will contain our layout for every page. (You can read more on <a href=\"https://kit.svelte.dev/docs/layouts\">SvelteKit Doc</a>). So our navigation between 2 of content types will be here and it'll look like the image below.<br>\n<img src=\"https://i.imgur.com/zwgOfw5.png\" alt=\"overall\"><br>\nBoth <code>blog</code> and <code>works</code> routes are similar because they need to have these nested routes.</p>\n<ul>\n<li><code>index</code> is a page that will show us a list of our contents and some buttons to manage those contents. It'll look like the right side of a picture in <em>What I need in my CMS?</em> section.<br>\n<img src=\"https://i.imgur.com/m4qcIlX.png\" alt=\"data table\"></li>\n<li><code>create</code> and <code>edit/[some identifier]</code> is a page that will show us what information we need to provide to that content type. It'll look like the picture in <em>What I need in my CMS?</em> section too. <img src=\"https://i.imgur.com/dtAOtrc.png\" alt=\"create\"></li>\n</ul>\n<p><strong>Implementation</strong><br>\nFirst,  <code>__layout.svelte</code> is a simple svelte component with a few SMUI components inside it, nothing interesting.<br>\n<br>\nNext, <code>index.svelte</code> will contain <a href=\"https://sveltematerialui.com/demo/data-table/\">SMUI Data Table</a> with data from our API by using <a href=\"https://kit.svelte.dev/docs/loading\">SvelteKit Loading</a> by below code (blog route example).</p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span> context=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Load</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sveltejs/kit&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">load</span>: <span class=\"hljs-title class_\">Load</span> = <span class=\"hljs-keyword\">async</span> ({ fetch }) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/post&#x27;</span>);\n\t\t<span class=\"hljs-keyword\">const</span> posts = (<span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>[];\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">props</span>: { posts } };\n\t};\n&lt;/script&gt;\n</code></pre>\n<p>Last, let's look at how I implement <code>create.svelte</code> and <code>edit/[slug].svelte</code> of blog route. Both of these pages will contain the same component <code>Blogcard</code> that will has properties of <code>type Blog</code>. <code>Blogcard</code> will provide us with data visualization and input forms.<br>\n<br>\nSo in <code>create.svelte</code>, we will have an empty <code>Blogcard</code> that we need to fill the forms and we can save those data by fetching our API (below code).</p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> { goto } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$app/navigation&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">BlogContent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Blogcard</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/components/blogcard.svelte&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleSave</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">event: <span class=\"hljs-built_in\">any</span></span>) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> blogpost = event.<span class=\"hljs-property\">detail</span>.<span class=\"hljs-property\">blogpost</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/post&#x27;</span>, {\n\t\t\t<span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n\t\t\t<span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(blogpost)\n\t\t});\n\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">200</span>) {\n\t\t\t<span class=\"hljs-title function_\">goto</span>(<span class=\"hljs-string\">`/blog/edit/<span class=\"hljs-subst\">${event.detail.slug}</span>`</span>);\n\t\t}\n\t};\n&lt;/script&gt;\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Blogcard</span> <span class=\"hljs-attr\">on:save</span>=<span class=\"hljs-string\">{handleSave}</span> /&gt;</span></span>\n</code></pre>\n<p>Did you see something interesting? On <code>&lt;Blogcard on:save={handleSave} /&gt;</code>, what is <code>on:save={handleSave}</code>?. It's a <a href=\"https://svelte.dev/tutorial/event-forwarding\">Svelte Event Forwarding</a> mechanism. By using the below code on <code>Blogcard</code> component, we can handle <code>Blogcard</code> save button behavior on an upper component.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title function_\">createEventDispatcher</span>();\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSave</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) =&gt; {\n\t<span class=\"hljs-keyword\">if</span> (filled) { <span class=\"hljs-comment\">// check if forms if filled</span>\n\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">blogpost</span>: <span class=\"hljs-title class_\">BlogContent</span> = {\n\t\t\ttitle,\n\t\t\tdescription,\n\t\t\tcontent\n\t\t};\n\t\t<span class=\"hljs-title function_\">dispatch</span>(<span class=\"hljs-string\">&#x27;save&#x27;</span>, { blogpost, slug }); <span class=\"hljs-comment\">// dispatch event data</span>\n\t}\n};\n</code></pre>\n<p>Now, in <code>edit/[slug].svelte</code> there is significant only one changes from <code>create.svelte</code>.<br>\n<br>\nWe are using square brackets on Svelte component file. This is a SvelteKit dynamic parameters.</p>\n<blockquote>\n<p>From <a href=\"https://kit.svelte.dev/docs/routing#pages\">SvelteKit Doc</a><br>\nDynamic parameters are encoded using¬†<code>[brackets]</code>. For example, a blog post might be defined by¬†<code>src/routes/blog/[slug].svelte</code>. These parameters can be accessed in a¬†<a href=\"https://kit.svelte.dev/docs/loading#input-params\"><code>load</code></a>¬†function or via the¬†<a href=\"https://kit.svelte.dev/docs/modules#$app-stores\"><code>page</code></a>¬†store.</p>\n</blockquote>\n<p>Now we can use dynamic parameters to fetch our blog content that we want to edit and show it on <code>Blogcard</code> by providing its properties with fetched blog content. We can use <a href=\"https://svelte.dev/tutorial/spread-props\">Svelte Spread Props</a> for more compact code too.<br>\n<br>\n<em>Above paragraph in code.</em></p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span> context=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Load</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sveltejs/kit&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span>, <span class=\"hljs-title class_\">BlogContent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">load</span>: <span class=\"hljs-title class_\">Load</span> = <span class=\"hljs-keyword\">async</span> ({ fetch, params }) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/post?slug=<span class=\"hljs-subst\">${params.slug}</span>`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> post = (<span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>;\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">props</span>: { post } };\n\t};\n&lt;/script&gt;\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ts&quot;</span>&gt;</span><span class=\"language-javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">post</span>: <span class=\"hljs-title class_\">Blog</span>;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Blogcard</span> {<span class=\"hljs-attr\">...post</span>} <span class=\"hljs-attr\">on:save</span>=<span class=\"hljs-string\">{handleSave}</span> /&gt;</span></span>\n</code></pre>\n<p>For <code>works</code> route the implementation is the same as <code>blog</code> route. You can view all source code on <a href=\"https://github.com/RiwEZ/TanatBlog\">TanatBlog</a> repo.</p>\n<h3>Conclusion</h3>\n<p>Yeyyy! I finished creating my own CMS for my blog. We have learned how to create basic <a href=\"https://kit.svelte.dev/\">SvelteKit</a> web-app with <a href=\"https://sveltematerialui.com/\">SMUI</a> and <a href=\"https://tailwindcss.com/\">tailwindcss</a> and using <a href=\"https://jestjs.io/\">Jest</a> to test backend too. If you have any question please comment below or <a href=\"/TanatBlog/contact\">contact me</a>, and be sure to check <a href=\"https://github.com/RiwEZ/TanatBlog\">TanatBlog</a> repo.</p>\n<blockquote>\n<p>This project was fun, but it took way too many times for me üòÖ. Hope this blog will help others do similar project faster!!!</p>\n</blockquote>\n","slug":"changing-from-strapi-to-my-owm-cms","createdAt":"2022-06-03T12:12:26.069Z","updatedAt":"2022-06-03T12:26:34.917Z"},{"title":"How I use Strapi as CMS for this blog.","description":"Using Strapi to create blog posts api endpoints and host it on Heroku or Render","content":"*Note: This blog is heavily inspired by [this blog post from strapi](https://strapi.io/blog/how-to-create-a-blog-with-svelte-kit-strapi)*\n\n\\\nToday, I'll tell you how I manage articles for this blog using [Strapi](https://strapi.io/) and hosting it via [Heroku](https://www.heroku.com/) and [Render](https://render.com/). \n\n### Prerequisite\n- [NodeJs](https://nodejs.org/en/) and [NPM](https://www.npmjs.com/) installed on your machine.\n- Some basic JavaScript and [Strapi](https://strapi.io/) knowledge.\n\n### Create Strapi Project\nRun this command on an empty folder to create a Strapi project called `cms` and wait for Strapi to create itself.\n```bash\nnpx create-strapi-app cms --quickstart\n```\nIf Strapi hasn't run yet, use this command in `cms` folder.\n```bash\nnpm run develop\n```\nNow, Strapi should start on [http://localhost:1337/](http://localhost:1337/) and show this signup page.\n\n<img src=\"https://i.imgur.com/SnHWxRI.png\" alt=\"signup\" width=50%> </img>\n\nContinue by signing up and we should get to the Admin page.\n\n#### Creating content types\nFind `Content-Type Builder` page and create new collection types `Post` with \n- A `title` field with type `Text`\n- A `description` field with type `Text` (`Short text` or `Long text` is up to you)\n- A `content` field with `Rich Text` type\n- A `slug` field with `UID` type and attached to `title` \n\nWe are using Strapi for our personal blog so no need for any `Relation` between user and article.\n![content types](https://i.imgur.com/V809v5X.png)\n\n#### Setting up roles and permissions\nFirst, find `Settings` button on sidebar then click on `Roles` in `USERS & PERMISSIONS PLUGIN` section. Next, select `Public` role and edit permissions of `Post` to only allow `findOne` and `find`.\n![permisson](https://i.imgur.com/0ybGQuN.png)\n\nAfter we finished setting up permissions, try adding some test data on `Content Manger`. Now, we should be able to use [http://localhost:1337/api/post](http://localhost:1337/api/post)  and see the test data we put in.\n\n### Hosting\nStrapi has a guide for many hosting platforms for you to select. (see. [Strapi Deployment](https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/deployment.html)).\n\nI have tried hosting on [Heroku](https://dashboard.heroku.com/) and [Render](https://render.com/) and I think both platforms is good to host a Strapi for our blog so I'll tell you how I host my Strapi with both platforms.\n\n#### Hosting on Heroku\nJust follow [Strapi Heroku Deployment](https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/deployment/hosting-guides/heroku.html#heroku-install-requirements) and you should have Strapi up on Heroku server.\n\n#### Hosting on Render\nYou can explore your options in this [article from Render](https://render.com/docs/deploy-strapi). For me, I'm going to use an \"Optimize for Cost and Simplicity\" option because it's simple, inexpensive and I think I don't need any scaling or zero downtime deploys thing. (*Note that if you want to try the same way with me, you need to at least pay for starter plan.*)\n\\\n**Configuration steps.**\n1. Create Render Blueprint by creating file `render.yaml`.\n\t```yaml\n\t# ./render.yaml\n\tservices:\n\t  - type: web\n\t    name: strapi\n\t    env: node\n\t    region: singapore # optional\n\t    plan: starter # need to be at least starter for persistent disk\n\t    buildCommand: npm install && npm run build\n\t    startCommand: rsync -a public/ /data/public/ && npm run start\n\t    healthCheckPath: /_health\n\t    disk:\n\t      name: strapi-data\n\t      mountPath: /data\n\t      sizeGB: 1\n\t    envVars:\n\t      - key: NODE_VERSION\n\t        value: ~16.13.0\n\t      - key: NODE_ENV\n\t        value: production\n\t      - key: DATABASE_FILENAME\n\t        value: /data/strapi.db\n\t      - key: JWT_SECRET\n\t        generateValue: true\n\t      - key: ADMIN_JWT_SECRET\n\t        generateValue: true\n\t      - key: APP_KEYS\n\t        generateValue: true\n\t```\n\tIn build and start command you can use yarn instead of npm, if you want.\n2. Add `./config/env/production/server.js` file.\n\t```js\n\t// ./config/env/production/server.js\n\tmodule.exports = ({ env }) => ({\n\t\turl: env(\"RENDER_EXTERNAL_URL\"),\n\t\tdirs: {\n\t\tpublic: \"/data/public\"\n\t\t},\n\t});\n\t```\n3. Edit `./config/database.js` file.\n\t```js\n\t// ./config/database.js\n\tconst path = require('path');\n\t\n\tmodule.exports = ({ env }) => ({\n\t  connection: {\n\t    client: 'sqlite',\n\t    connection: {\n\t\t    // filename: path.join(__dirname, '..', env('DATABASE_FILENAME', '.tmp/data.db')),\n\t\t    filename: env('DATABASE_FILENAME', path.join(__dirname, '..', '.tmp/data.db')),\n\t    },\n\t    useNullAsDefault: true,\n\t  },\n\t});\n\n\t```\n4. Push your changes to GitHub or GitLab and [create an instance of your Blueprint](https://render.com/docs/infrastructure-as-code#getting-started) from the [Render dashboard](https://dashboard.render.com/).\n\nFinally, we should have Strapi up on Render server ready for our blog website.\n\n##### Using pm2 to manage process\nStrapi recommends you use [pm2](https://github.com/Unitech/pm2/) to help manage Strapi process. We will be doing this by\n1. Install pm2 as a dependency\n\t```\n\tnpm i pm2\n\t```\n2. Create `server.js` file.\n\t```js\n\t// ./server.js\n\tconst strapi = require('@strapi/strapi');\n\tstrapi().start();\n\t```\n3. Create `ecosystem.config.js` by yourself or `pm2 init` (if you have installed pm2 globally)\n\t```js \n\t// ./ecosystem.config.js\n\tmodule.exports = {\n\t  apps: [\n\t    {\n\t      name: \"app\",\n\t      script: \"./server.js\",\n\t      instance: \"max\",\n\t      exec_moode: \"cluster\",\n\t      env_production: {\n\t        NODE_ENV: \"production\",\n\t      },\n\t    },\n\t  ],\n\t};\n\t```\n\tIf you wonder what is all these configs please visit [pm2 doc](https://pm2.keymetrics.io/docs/usage/application-declaration/)\n4. Edit `package.json` by changing `start` command.\n\t```json\n\t\"scripts\": {\n\t...,\n    \"start\": \"pm2-runtime start ecosystem.config.js --env production\",\n    ...\n\t},\n\t```\n\nNow, If you commit and push these additions to Heroku or Render, you should see some `PM2 log` in logs.\n\n### Conclusion\nHooray! Now, you have a CMS ready for your personal blog and already online on Heroku/Render Server. If you have any question please comment below or [contact me](/TanatBlog/contact), and be sure to check [Strapi Docs](https://docs.strapi.io/developer-docs/latest/getting-started/introduction.html), [pm2 Docs](https://pm2.keymetrics.io/docs/usage/quick-start/), and [source code on Github](https://github.com/RiwEZ/TanatBlogCMS) first.","createdAt":"2022-04-10T11:45:46.229Z","updatedAt":"2022-04-10T11:45:46.229Z","slug":"how-i-use-strapi-as-cms-for-this-blog","htmlContent":"<p><em>Note: This blog is heavily inspired by <a href=\"https://strapi.io/blog/how-to-create-a-blog-with-svelte-kit-strapi\">this blog post from strapi</a></em></p>\n<p><br>\nToday, I'll tell you how I manage articles for this blog using <a href=\"https://strapi.io/\">Strapi</a> and hosting it via <a href=\"https://www.heroku.com/\">Heroku</a> and <a href=\"https://render.com/\">Render</a>.</p>\n<h3>Prerequisite</h3>\n<ul>\n<li><a href=\"https://nodejs.org/en/\">NodeJs</a> and <a href=\"https://www.npmjs.com/\">NPM</a> installed on your machine.</li>\n<li>Some basic JavaScript and <a href=\"https://strapi.io/\">Strapi</a> knowledge.</li>\n</ul>\n<h3>Create Strapi Project</h3>\n<p>Run this command on an empty folder to create a Strapi project called <code>cms</code> and wait for Strapi to create itself.</p>\n<pre class=\"hljs\"><code>npx create-strapi-app cms --quickstart\n</code></pre>\n<p>If Strapi hasn't run yet, use this command in <code>cms</code> folder.</p>\n<pre class=\"hljs\"><code>npm run develop\n</code></pre>\n<p>Now, Strapi should start on <a href=\"http://localhost:1337/\">http://localhost:1337/</a> and show this signup page.</p>\n<p><img src=\"https://i.imgur.com/SnHWxRI.png\" alt=\"signup\" width=50%> </img></p>\n<p>Continue by signing up and we should get to the Admin page.</p>\n<h4>Creating content types</h4>\n<p>Find <code>Content-Type Builder</code> page and create new collection types <code>Post</code> with</p>\n<ul>\n<li>A <code>title</code> field with type <code>Text</code></li>\n<li>A <code>description</code> field with type <code>Text</code> (<code>Short text</code> or <code>Long text</code> is up to you)</li>\n<li>A <code>content</code> field with <code>Rich Text</code> type</li>\n<li>A <code>slug</code> field with <code>UID</code> type and attached to <code>title</code></li>\n</ul>\n<p>We are using Strapi for our personal blog so no need for any <code>Relation</code> between user and article.<br>\n<img src=\"https://i.imgur.com/V809v5X.png\" alt=\"content types\"></p>\n<h4>Setting up roles and permissions</h4>\n<p>First, find <code>Settings</code> button on sidebar then click on <code>Roles</code> in <code>USERS &amp; PERMISSIONS PLUGIN</code> section. Next, select <code>Public</code> role and edit permissions of <code>Post</code> to only allow <code>findOne</code> and <code>find</code>.<br>\n<img src=\"https://i.imgur.com/0ybGQuN.png\" alt=\"permisson\"></p>\n<p>After we finished setting up permissions, try adding some test data on <code>Content Manger</code>. Now, we should be able to use <a href=\"http://localhost:1337/api/post\">http://localhost:1337/api/post</a>  and see the test data we put in.</p>\n<h3>Hosting</h3>\n<p>Strapi has a guide for many hosting platforms for you to select. (see. <a href=\"https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/deployment.html\">Strapi Deployment</a>).</p>\n<p>I have tried hosting on <a href=\"https://dashboard.heroku.com/\">Heroku</a> and <a href=\"https://render.com/\">Render</a> and I think both platforms is good to host a Strapi for our blog so I'll tell you how I host my Strapi with both platforms.</p>\n<h4>Hosting on Heroku</h4>\n<p>Just follow <a href=\"https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/deployment/hosting-guides/heroku.html#heroku-install-requirements\">Strapi Heroku Deployment</a> and you should have Strapi up on Heroku server.</p>\n<h4>Hosting on Render</h4>\n<p>You can explore your options in this <a href=\"https://render.com/docs/deploy-strapi\">article from Render</a>. For me, I'm going to use an &quot;Optimize for Cost and Simplicity&quot; option because it's simple, inexpensive and I think I don't need any scaling or zero downtime deploys thing. (<em>Note that if you want to try the same way with me, you need to at least pay for starter plan.</em>)<br>\n<br>\n<strong>Configuration steps.</strong></p>\n<ol>\n<li>Create Render Blueprint by creating file <code>render.yaml</code>.<pre class=\"hljs\"><code><span class=\"hljs-comment\"># ./render.yaml</span>\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">web</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">strapi</span>\n    <span class=\"hljs-attr\">env:</span> <span class=\"hljs-string\">node</span>\n    <span class=\"hljs-attr\">region:</span> <span class=\"hljs-string\">singapore</span> <span class=\"hljs-comment\"># optional</span>\n    <span class=\"hljs-attr\">plan:</span> <span class=\"hljs-string\">starter</span> <span class=\"hljs-comment\"># need to be at least starter for persistent disk</span>\n    <span class=\"hljs-attr\">buildCommand:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span>\n    <span class=\"hljs-attr\">startCommand:</span> <span class=\"hljs-string\">rsync</span> <span class=\"hljs-string\">-a</span> <span class=\"hljs-string\">public/</span> <span class=\"hljs-string\">/data/public/</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">start</span>\n    <span class=\"hljs-attr\">healthCheckPath:</span> <span class=\"hljs-string\">/_health</span>\n    <span class=\"hljs-attr\">disk:</span>\n      <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">strapi-data</span>\n      <span class=\"hljs-attr\">mountPath:</span> <span class=\"hljs-string\">/data</span>\n      <span class=\"hljs-attr\">sizeGB:</span> <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-attr\">envVars:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">NODE_VERSION</span>\n        <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">~16.13.0</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">NODE_ENV</span>\n        <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">production</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">DATABASE_FILENAME</span>\n        <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">/data/strapi.db</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">JWT_SECRET</span>\n        <span class=\"hljs-attr\">generateValue:</span> <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">ADMIN_JWT_SECRET</span>\n        <span class=\"hljs-attr\">generateValue:</span> <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">APP_KEYS</span>\n        <span class=\"hljs-attr\">generateValue:</span> <span class=\"hljs-literal\">true</span>\n</code></pre>\nIn build and start command you can use yarn instead of npm, if you want.</li>\n<li>Add <code>./config/env/production/server.js</code> file.<pre class=\"hljs\"><code><span class=\"hljs-comment\">// ./config/env/production/server.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ env }</span>) =&gt;</span> ({\n\t<span class=\"hljs-attr\">url</span>: <span class=\"hljs-title function_\">env</span>(<span class=\"hljs-string\">&quot;RENDER_EXTERNAL_URL&quot;</span>),\n\t<span class=\"hljs-attr\">dirs</span>: {\n\t<span class=\"hljs-attr\">public</span>: <span class=\"hljs-string\">&quot;/data/public&quot;</span>\n\t},\n});\n</code></pre>\n</li>\n<li>Edit <code>./config/database.js</code> file.<pre class=\"hljs\"><code><span class=\"hljs-comment\">// ./config/database.js</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ env }</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">connection</span>: {\n    <span class=\"hljs-attr\">client</span>: <span class=\"hljs-string\">&#x27;sqlite&#x27;</span>,\n    <span class=\"hljs-attr\">connection</span>: {\n\t    <span class=\"hljs-comment\">// filename: path.join(__dirname, &#x27;..&#x27;, env(&#x27;DATABASE_FILENAME&#x27;, &#x27;.tmp/data.db&#x27;)),</span>\n\t    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-title function_\">env</span>(<span class=\"hljs-string\">&#x27;DATABASE_FILENAME&#x27;</span>, path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;..&#x27;</span>, <span class=\"hljs-string\">&#x27;.tmp/data.db&#x27;</span>)),\n    },\n    <span class=\"hljs-attr\">useNullAsDefault</span>: <span class=\"hljs-literal\">true</span>,\n  },\n});\n\n</code></pre>\n</li>\n<li>Push your changes to GitHub or GitLab and <a href=\"https://render.com/docs/infrastructure-as-code#getting-started\">create an instance of your Blueprint</a> from the <a href=\"https://dashboard.render.com/\">Render dashboard</a>.</li>\n</ol>\n<p>Finally, we should have Strapi up on Render server ready for our blog website.</p>\n<h5>Using pm2 to manage process</h5>\n<p>Strapi recommends you use <a href=\"https://github.com/Unitech/pm2/\">pm2</a> to help manage Strapi process. We will be doing this by</p>\n<ol>\n<li>Install pm2 as a dependency<pre class=\"hljs\"><code>npm i pm2\n</code></pre>\n</li>\n<li>Create <code>server.js</code> file.<pre class=\"hljs\"><code><span class=\"hljs-comment\">// ./server.js</span>\n<span class=\"hljs-keyword\">const</span> strapi = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@strapi/strapi&#x27;</span>);\n<span class=\"hljs-title function_\">strapi</span>().<span class=\"hljs-title function_\">start</span>();\n</code></pre>\n</li>\n<li>Create <code>ecosystem.config.js</code> by yourself or <code>pm2 init</code> (if you have installed pm2 globally)<pre class=\"hljs\"><code><span class=\"hljs-comment\">// ./ecosystem.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">apps</span>: [\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;app&quot;</span>,\n      <span class=\"hljs-attr\">script</span>: <span class=\"hljs-string\">&quot;./server.js&quot;</span>,\n      <span class=\"hljs-attr\">instance</span>: <span class=\"hljs-string\">&quot;max&quot;</span>,\n      <span class=\"hljs-attr\">exec_moode</span>: <span class=\"hljs-string\">&quot;cluster&quot;</span>,\n      <span class=\"hljs-attr\">env_production</span>: {\n        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">&quot;production&quot;</span>,\n      },\n    },\n  ],\n};\n</code></pre>\nIf you wonder what is all these configs please visit <a href=\"https://pm2.keymetrics.io/docs/usage/application-declaration/\">pm2 doc</a></li>\n<li>Edit <code>package.json</code> by changing <code>start</code> command.<pre class=\"hljs\"><code><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n...<span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;start&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;pm2-runtime start ecosystem.config.js --env production&quot;</span><span class=\"hljs-punctuation\">,</span>\n...\n<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n</li>\n</ol>\n<p>Now, If you commit and push these additions to Heroku or Render, you should see some <code>PM2 log</code> in logs.</p>\n<h3>Conclusion</h3>\n<p>Hooray! Now, you have a CMS ready for your personal blog and already online on Heroku/Render Server. If you have any question please comment below or <a href=\"/TanatBlog/contact\">contact me</a>, and be sure to check <a href=\"https://docs.strapi.io/developer-docs/latest/getting-started/introduction.html\">Strapi Docs</a>, <a href=\"https://pm2.keymetrics.io/docs/usage/quick-start/\">pm2 Docs</a>, and <a href=\"https://github.com/RiwEZ/TanatBlogCMS\">source code on Github</a> first.</p>\n"}]