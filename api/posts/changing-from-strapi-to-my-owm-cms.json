{"title":"Changing from Strapi to my owm CMS.","description":"How I implement my own CMS and why I do it.","content":"In this blog, I'll tell you how I build my own CMS to manage my contents on this website. \n\n## Why not use Strapi?\nFirst of all, why not just use Strapi? Strapi is a great CMS, but we only manage a few simple contents like blog markdown and information on my work. So, using Strapi seems to be overengineering, and I can save my money by not hosting Strapi. \n\n## What do I need in my CMS?\nOverall, I want a Strapi-like UI for managing my blogs and works. It should look something like this.\n\\\n*Overall UI, left side is a navigation tab and right side is a page*\n![overall](https://i.imgur.com/zwgOfw5.png) *Create/Edit blog UI.*\n![create](https://i.imgur.com/dtAOtrc.png)\n\nAnd I don't want to host it, so I'll only use development server to run this web and push changes to Github after our contents have been handled.\n\\\nI'll be using YAML files as a database because we can easily manage YAML files by using this package [js-yaml](https://www.npmjs.com/package/js-yaml). Other options might be SQLite or MySQL. So we also need a backend code using `js-yaml` package to manage my database.\n\n\n## How do I build my own CMS?\nBefore we build anything, let's set up [SvelteKit](https://kit.svelte.dev/) project first.\nI run `npm init svelte .` in `admin/` folder and use all options in the image below. \n![svelte options](https://i.imgur.com/OUNjS9f.png)\n### Backend \nNext, let's create our backend. I want 2 types of data schema for blog and work.\n\\\n**Blog Data Schema**\n`BlogContent` interface will be our input and `Blog` will be our object to save on our database.\n```ts\n// admin/src/lib/blog.ts\nexport interface BlogContent extends JSONObject {\n\ttitle: string;\n\tdescription: string;\n\tcontent: string;\n}\n\nexport interface Blog extends BlogContent {\n\thtmlContent: string;\n\tslug: string;\n\tcreatedAt: string;\n\tupdatedAt: string;\n}\n```\n\\\n**Work Data Schema**\nSame with the Blog Data Scheme, `WorkContent` will be our input and `Work` will be our object to save on our database.\n```ts\n// admin/src/lib/work_manager.ts\nexport interface Link extends JSONObject {\n\thref: string;\n\ttext: string;\n}\n\nexport interface WorkContent extends JSONObject {\n\ttitle: string;\n\ttags: string[];\n\tlinks: Link[];\n\tbody: string;\n\t}\n\nexport interface Work extends WorkContent {\n\tid: number;\n}\n```\nAnd now we need a backend code to manage these data schemas. First, I'll write some tests for our backend code.\n\\\n**Backend Testing & Development**\nI'll use [Jest](https://jestjs.io/) to test our backend code. First install it via `npm install -D jest ts-jest @types/jest` and in  `package.json` add jest configuration for `ts` using `ts-jest` and [ECMAScript Modules](https://jestjs.io/docs/ecmascript-modules) configuration.\n```json\n// admin/package.json\n{\n\t...,\n\t\"jest\": {\n\t\t\"testEnvironment\": \"node\",\n\t\t\"transform\": {\n\t\t\t\"\\\\.[jt]sx?$\": \"ts-jest\"\n\t\t},\n\t\t\"preset\": \"ts-jest/presets/default-esm\",\n\t\t\"globals\": {\n\t\t\t\"ts-jest\": {\n\t\t\t\t\"useESM\": true\n\t\t\t}\n\t\t},\n\t\t\"moduleNameMapper\": {\n\t\t\t\"^(\\\\.{1,2}/.*)\\\\.js$\": \"$1\"\n\t\t}\n\t},\n\t\"scripts\": {\n\t\t...,\n\t\t\"jest\": \"node --experimental-vm-modules node_modules/jest/bin/jest.js ./src\",\n\t},\n}\n```\nIn our backend, we should be able to add, edit, delete and get from our database and these methods should be in our data structure class `BlogManager` and `WorkManager`. So we need to write a test for these methods.\n\\\nAn example of my test cases.\n```ts\n// admin/src/lib/blog.test.ts\nconst path = './tests/data/blogs';\nconst bm = new BlogManager(path);\n\ntest('Can add new blog?', () => {\n\tconst title = 'test add';\n\tconst blog: BlogContent = {\n\t\ttitle,\n\t\tdescription: 'test blog',\n\t\tcontent: 'Lorem .....'\n\t};\n\tconst ret = bm.add(blog);\n\texpect(ret).toEqual(true);\n\t// file name is a slug of title\n\tconst resultPath = `${path}/test-add.yaml`;\n\tconst result = yaml.load(readFileSync(resultPath, 'utf-8')) as BlogContent;\n\texpect(result).toBeDefined();\n\texpect(result.title).toEqual(blog.title);\n\texpect(result.description).toEqual(blog.description);\n\texpect(result.content).toEqual(blog.content);\n\t// remove that blog after done testing\n\tif (existsSync(resultPath)) unlinkSync(resultPath);\n});\n```\n\\\nAnd let's implement `BlogManager` class that will pass this test case.\n```ts\n// admin/src/lib/blog.ts\nexport default class BlogManager {\n\tpath: string;\n\t\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t}\n\t\n\tstatic slug(title: string): string {\n\t\treturn title\n\t\t.toLowerCase()\n\t\t.trim()\n\t\t.replace(/ /g, '-')\n\t\t.replace(/[.\\\\/:*?\"<>|]/g, '');\n\t}\n\n\tadd(blog: BlogContent): boolean {\n\t\tconst slug = BlogManager.slug(blog.title);\n\t\tconst path = `${this.path}/${slug}.yaml`;\n\t\tif (!existsSync(path)) {\n\t\t\tconst date = new Date().toISOString();\n\t\t\tconst data = blog as Blog;\n\t\t\tdata.htmlContent = md(blog.content);\n\t\t\tdata.slug = slug;\n\t\t\tdata.createdAt = date;\n\t\t\tdata.updatedAt = date;\n\t\t\twriteFileSync(path, yaml.dump(data));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\nFor `WorkManager` and other methods, the development process is the same as above. You can see all the codes on [admin/src/lib](https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/lib).\n\\\n**API Routes**\nNow, I need to create an API that our frontend web can use because we can't use `BlogManager` and `WorkManager` class directly on SvelteKit page. In SvelteKit, we can create our API by using [Standalone endpoints](https://kit.svelte.dev/docs/routing#endpoints-standalone-endpoints)\n\\\nTherefore, we will use `BlogManager` and `WorkManager` class to create our REST API. Where our endpoints `request` will contain any information necessary for our data structure class.\n\\\nAn example of my endpoints. For full source code, you can visit [admin/src/routes/api](https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/routes/api).\n```ts\n// admin/src/routes/api/post.ts\nconst bm = new BlogManager('../src/data/blogs');\n\nexport const post: RequestHandler = async ({ request }) => {\n\tconst data = (await request.json()) as BlogContent;\n\tif (bm.add(data)) return { status: 200 };\n\t\treturn { status: 500 };\n};\n...\n```\n\n### Frontend\nLastly, let's create our frontend using [SMUI](https://sveltematerialui.com/) and [tailwindcss](https://tailwindcss.com/). \n\\\nSetting up SMUI can be done by following this [guide](https://sveltematerialui.com/SVELTEKIT.md) (I wish this could be simpler) and setting up tailwindcss by following this [guide](https://tailwindcss.com/docs/guides/sveltekit) but in `app.css` only add `@tailwind components` and `@tailwind utilities` because `@tailwind base` will override some of SMUI styling.\n\\\n**Overview**\nAfter all the setup, I need to create all of [SvelteKit Pages](https://kit.svelte.dev/docs/routing#pages) that we will need.\n\nThis is a list of svelte files on `admin/src/routes` for all of our pages.\n```\nPS>> tree /f\n│   index.svelte\n│   __layout.svelte\n│\n├───blog\n│   │   create.svelte\n│   │   index.svelte\n│   │\n│   └───edit\n│           [slug].svelte\n│\n└───works\n    │   create.svelte\n    │   index.svelte\n    │\n    └───edit\n            [id].svelte\n```\n\n`__layout.svelte` is a file that will contain our layout for every page. (You can read more on [SvelteKit Doc](https://kit.svelte.dev/docs/layouts)). So our navigation between 2 of content types will be here and it'll look like the image below.\n![overall](https://i.imgur.com/zwgOfw5.png)\nBoth `blog` and `works` routes are similar because they need to have these nested routes.\n- `index` is a page that will show us a list of our contents and some buttons to manage those contents. It'll look like the right side of a picture in *What I need in my CMS?* section.\n\t![data table](https://i.imgur.com/m4qcIlX.png)\n- `create` and `edit/[some identifier]` is a page that will show us what information we need to provide to that content type. It'll look like the picture in *What I need in my CMS?* section too. ![create](https://i.imgur.com/dtAOtrc.png)\n\n**Implementation**\nFirst,  `__layout.svelte` is a simple svelte component with a few SMUI components inside it, nothing interesting.\n\\\nNext, `index.svelte` will contain [SMUI Data Table](https://sveltematerialui.com/demo/data-table/) with data from our API by using [SvelteKit Loading](https://kit.svelte.dev/docs/loading) by below code (blog route example).\n```ts\n<script lang=\"ts\" context=\"module\">\n\timport type { Load } from '@sveltejs/kit';\n\timport type { Blog } from '$lib/blog';\n\n\texport const load: Load = async ({ fetch }) => {\n\t\tconst resp = await fetch('/api/post');\n\t\tconst posts = (await resp.json()) as Blog[];\n\t\treturn { props: { posts } };\n\t};\n</script>\n```\nLast, let's look at how I implement `create.svelte` and `edit/[slug].svelte` of blog route. Both of these pages will contain the same component `Blogcard` that will has properties of `type Blog`. `Blogcard` will provide us with data visualization and input forms. \n\\\nSo in `create.svelte`, we will have an empty `Blogcard` that we need to fill the forms and we can save those data by fetching our API (below code).\n```ts\n<script lang=\"ts\">\n\timport { goto } from '$app/navigation';\n\timport type { BlogContent } from '$lib/blog';\n\timport Blogcard from '$lib/components/blogcard.svelte';\n\n\tconst handleSave = async (event: any) => {\n\t\tconst blogpost = event.detail.blogpost as BlogContent;\n\t\tconst res = await fetch('/api/post', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify(blogpost)\n\t\t});\n\t\tif (res.status === 200) {\n\t\t\tgoto(`/blog/edit/${event.detail.slug}`);\n\t\t}\n\t};\n</script>\n<Blogcard on:save={handleSave} />\n```\nDid you see something interesting? On `<Blogcard on:save={handleSave} />`, what is `on:save={handleSave}`?. It's a [Svelte Event Forwarding](https://svelte.dev/tutorial/event-forwarding) mechanism. By using the below code on `Blogcard` component, we can handle `Blogcard` save button behavior on an upper component.\n```ts\nconst dispatch = createEventDispatcher();\nconst onSave = async () => {\n\tif (filled) { // check if forms if filled\n\t\tconst blogpost: BlogContent = {\n\t\t\ttitle,\n\t\t\tdescription,\n\t\t\tcontent\n\t\t};\n\t\tdispatch('save', { blogpost, slug }); // dispatch event data\n\t}\n};\n```\nNow, in `edit/[slug].svelte` there is significant only one changes from `create.svelte`. \n\\\nWe are using square brackets on Svelte component file. This is a SvelteKit dynamic parameters.\n> From [SvelteKit Doc](https://kit.svelte.dev/docs/routing#pages)\n> Dynamic parameters are encoded using `[brackets]`. For example, a blog post might be defined by `src/routes/blog/[slug].svelte`. These parameters can be accessed in a [`load`](https://kit.svelte.dev/docs/loading#input-params) function or via the [`page`](https://kit.svelte.dev/docs/modules#$app-stores) store.\n\nNow we can use dynamic parameters to fetch our blog content that we want to edit and show it on `Blogcard` by providing its properties with fetched blog content. We can use [Svelte Spread Props](https://svelte.dev/tutorial/spread-props) for more compact code too.\n \\\n *Above paragraph in code.*\n```ts\n<script lang=\"ts\" context=\"module\">\n\timport type { Load } from '@sveltejs/kit';\n\timport type { Blog, BlogContent } from '$lib/blog';\n\n\texport const load: Load = async ({ fetch, params }) => {\n\t\tconst resp = await fetch(`/api/post?slug=${params.slug}`);\n\t\tconst post = (await resp.json()) as Blog;\n\t\treturn { props: { post } };\n\t};\n</script>\n\n<script lang=\"ts\">\n\texport let post: Blog;\n</script>\n\n<Blogcard {...post} on:save={handleSave} />\n```\nFor `works` route the implementation is the same as `blog` route. You can view all source code on [TanatBlog](https://github.com/RiwEZ/TanatBlog) repo.\n\n### Conclusion\nYeyyy! I finished creating my own CMS for my blog. We have learned how to create basic [SvelteKit](https://kit.svelte.dev/) web-app with [SMUI](https://sveltematerialui.com/) and [tailwindcss](https://tailwindcss.com/) and using [Jest](https://jestjs.io/) to test backend too. If you have any question please comment below or [contact me](/TanatBlog/contact), and be sure to check [TanatBlog](https://github.com/RiwEZ/TanatBlog) repo.\n\n> This project was fun, but it took way too many times for me 😅. Hope this blog will help others do similar project faster!!!","htmlContent":"<p>In this blog, I'll tell you how I build my own CMS to manage my contents on this website.</p>\n<h2>Why not use Strapi?</h2>\n<p>First of all, why not just use Strapi? Strapi is a great CMS, but we only manage a few simple contents like blog markdown and information on my work. So, using Strapi seems to be overengineering, and I can save my money by not hosting Strapi.</p>\n<h2>What do I need in my CMS?</h2>\n<p>Overall, I want a Strapi-like UI for managing my blogs and works. It should look something like this.<br>\n<br>\n<em>Overall UI, left side is a navigation tab and right side is a page</em><br>\n<img src=\"https://i.imgur.com/zwgOfw5.png\" alt=\"overall\"> <em>Create/Edit blog UI.</em><br>\n<img src=\"https://i.imgur.com/dtAOtrc.png\" alt=\"create\"></p>\n<p>And I don't want to host it, so I'll only use development server to run this web and push changes to Github after our contents have been handled.<br>\n<br>\nI'll be using YAML files as a database because we can easily manage YAML files by using this package <a href=\"https://www.npmjs.com/package/js-yaml\">js-yaml</a>. Other options might be SQLite or MySQL. So we also need a backend code using <code>js-yaml</code> package to manage my database.</p>\n<h2>How do I build my own CMS?</h2>\n<p>Before we build anything, let's set up <a href=\"https://kit.svelte.dev/\">SvelteKit</a> project first.<br>\nI run <code>npm init svelte .</code> in <code>admin/</code> folder and use all options in the image below.<br>\n<img src=\"https://i.imgur.com/OUNjS9f.png\" alt=\"svelte options\"></p>\n<h3>Backend</h3>\n<p>Next, let's create our backend. I want 2 types of data schema for blog and work.<br>\n<br>\n<strong>Blog Data Schema</strong><br>\n<code>BlogContent</code> interface will be our input and <code>Blog</code> will be our object to save on our database.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">BlogContent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Blog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BlogContent</span> {\n\t<span class=\"hljs-attr\">htmlContent</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">slug</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">createdAt</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">updatedAt</span>: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p><br>\n<strong>Work Data Schema</strong><br>\nSame with the Blog Data Scheme, <code>WorkContent</code> will be our input and <code>Work</code> will be our object to save on our database.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/work_manager.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Link</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">href</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">WorkContent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">JSON</span>Object {\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\t<span class=\"hljs-attr\">tags</span>: <span class=\"hljs-built_in\">string</span>[];\n\t<span class=\"hljs-attr\">links</span>: <span class=\"hljs-title class_\">Link</span>[];\n\t<span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">string</span>;\n\t}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Work</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">WorkContent</span> {\n\t<span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p>And now we need a backend code to manage these data schemas. First, I'll write some tests for our backend code.<br>\n<br>\n<strong>Backend Testing &amp; Development</strong><br>\nI'll use <a href=\"https://jestjs.io/\">Jest</a> to test our backend code. First install it via <code>npm install -D jest ts-jest @types/jest</code> and in  <code>package.json</code> add jest configuration for <code>ts</code> using <code>ts-jest</code> and <a href=\"https://jestjs.io/docs/ecmascript-modules\">ECMAScript Modules</a> configuration.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/package.json</span>\n<span class=\"hljs-punctuation\">{</span>\n\t...<span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-attr\">&quot;jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t<span class=\"hljs-attr\">&quot;testEnvironment&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;transform&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;\\\\.[jt]sx?$&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;ts-jest&quot;</span>\n\t\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;preset&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;ts-jest/presets/default-esm&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;globals&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;ts-jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t\t<span class=\"hljs-attr\">&quot;useESM&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\n\t\t\t<span class=\"hljs-punctuation\">}</span>\n\t\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;moduleNameMapper&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t\t<span class=\"hljs-attr\">&quot;^(\\\\.{1,2}/.*)\\\\.js$&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;$1&quot;</span>\n\t\t<span class=\"hljs-punctuation\">}</span>\n\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n\t\t...<span class=\"hljs-punctuation\">,</span>\n\t\t<span class=\"hljs-attr\">&quot;jest&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node --experimental-vm-modules node_modules/jest/bin/jest.js ./src&quot;</span><span class=\"hljs-punctuation\">,</span>\n\t<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>In our backend, we should be able to add, edit, delete and get from our database and these methods should be in our data structure class <code>BlogManager</code> and <code>WorkManager</code>. So we need to write a test for these methods.<br>\n<br>\nAn example of my test cases.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.test.ts</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-string\">&#x27;./tests/data/blogs&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> bm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BlogManager</span>(path);\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;Can add new blog?&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-string\">&#x27;test add&#x27;</span>;\n\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">blog</span>: <span class=\"hljs-title class_\">BlogContent</span> = {\n\t\ttitle,\n\t\t<span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&#x27;test blog&#x27;</span>,\n\t\t<span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">&#x27;Lorem .....&#x27;</span>\n\t};\n\t<span class=\"hljs-keyword\">const</span> ret = bm.<span class=\"hljs-title function_\">add</span>(blog);\n\t<span class=\"hljs-title function_\">expect</span>(ret).<span class=\"hljs-title function_\">toEqual</span>(<span class=\"hljs-literal\">true</span>);\n\t<span class=\"hljs-comment\">// file name is a slug of title</span>\n\t<span class=\"hljs-keyword\">const</span> resultPath = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${path}</span>/test-add.yaml`</span>;\n\t<span class=\"hljs-keyword\">const</span> result = yaml.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-title function_\">readFileSync</span>(resultPath, <span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t<span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toBeDefined</span>();\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">title</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">title</span>);\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">description</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">description</span>);\n\t<span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">content</span>).<span class=\"hljs-title function_\">toEqual</span>(blog.<span class=\"hljs-property\">content</span>);\n\t<span class=\"hljs-comment\">// remove that blog after done testing</span>\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">existsSync</span>(resultPath)) <span class=\"hljs-title function_\">unlinkSync</span>(resultPath);\n});\n</code></pre>\n<p><br>\nAnd let's implement <code>BlogManager</code> class that will pass this test case.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/lib/blog.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BlogManager</span> {\n\t<span class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\">string</span>;\n\t\n\t<span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">path: <span class=\"hljs-built_in\">string</span></span>) {\n\t\t<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">path</span> = path;\n\t}\n\t\n\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">slug</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-built_in\">string</span> {\n\t\t<span class=\"hljs-keyword\">return</span> title\n\t\t.<span class=\"hljs-title function_\">toLowerCase</span>()\n\t\t.<span class=\"hljs-title function_\">trim</span>()\n\t\t.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/ /g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>)\n\t\t.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[.\\\\/:*?&quot;&lt;&gt;|]/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>);\n\t}\n\n\t<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-attr\">blog</span>: <span class=\"hljs-title class_\">BlogContent</span>): <span class=\"hljs-built_in\">boolean</span> {\n\t\t<span class=\"hljs-keyword\">const</span> slug = <span class=\"hljs-title class_\">BlogManager</span>.<span class=\"hljs-title function_\">slug</span>(blog.<span class=\"hljs-property\">title</span>);\n\t\t<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.path}</span>/<span class=\"hljs-subst\">${slug}</span>.yaml`</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">existsSync</span>(path)) {\n\t\t\t<span class=\"hljs-keyword\">const</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toISOString</span>();\n\t\t\t<span class=\"hljs-keyword\">const</span> data = blog <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>;\n\t\t\tdata.<span class=\"hljs-property\">htmlContent</span> = <span class=\"hljs-title function_\">md</span>(blog.<span class=\"hljs-property\">content</span>);\n\t\t\tdata.<span class=\"hljs-property\">slug</span> = slug;\n\t\t\tdata.<span class=\"hljs-property\">createdAt</span> = date;\n\t\t\tdata.<span class=\"hljs-property\">updatedAt</span> = date;\n\t\t\t<span class=\"hljs-title function_\">writeFileSync</span>(path, yaml.<span class=\"hljs-title function_\">dump</span>(data));\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\t}\n}\n</code></pre>\n<p>For <code>WorkManager</code> and other methods, the development process is the same as above. You can see all the codes on <a href=\"https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/lib\">admin/src/lib</a>.<br>\n<br>\n<strong>API Routes</strong><br>\nNow, I need to create an API that our frontend web can use because we can't use <code>BlogManager</code> and <code>WorkManager</code> class directly on SvelteKit page. In SvelteKit, we can create our API by using <a href=\"https://kit.svelte.dev/docs/routing#endpoints-standalone-endpoints\">Standalone endpoints</a><br>\n<br>\nTherefore, we will use <code>BlogManager</code> and <code>WorkManager</code> class to create our REST API. Where our endpoints <code>request</code> will contain any information necessary for our data structure class.<br>\n<br>\nAn example of my endpoints. For full source code, you can visit <a href=\"https://github.com/RiwEZ/TanatBlog/tree/main/admin/src/routes/api\">admin/src/routes/api</a>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// admin/src/routes/api/post.ts</span>\n<span class=\"hljs-keyword\">const</span> bm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BlogManager</span>(<span class=\"hljs-string\">&#x27;../src/data/blogs&#x27;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">post</span>: <span class=\"hljs-title class_\">RequestHandler</span> = <span class=\"hljs-keyword\">async</span> ({ request }) =&gt; {\n\t<span class=\"hljs-keyword\">const</span> data = (<span class=\"hljs-keyword\">await</span> request.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t<span class=\"hljs-keyword\">if</span> (bm.<span class=\"hljs-title function_\">add</span>(data)) <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">200</span> };\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">500</span> };\n};\n...\n</code></pre>\n<h3>Frontend</h3>\n<p>Lastly, let's create our frontend using <a href=\"https://sveltematerialui.com/\">SMUI</a> and <a href=\"https://tailwindcss.com/\">tailwindcss</a>.<br>\n<br>\nSetting up SMUI can be done by following this <a href=\"https://sveltematerialui.com/SVELTEKIT.md\">guide</a> (I wish this could be simpler) and setting up tailwindcss by following this <a href=\"https://tailwindcss.com/docs/guides/sveltekit\">guide</a> but in <code>app.css</code> only add <code>@tailwind components</code> and <code>@tailwind utilities</code> because <code>@tailwind base</code> will override some of SMUI styling.<br>\n<br>\n<strong>Overview</strong><br>\nAfter all the setup, I need to create all of <a href=\"https://kit.svelte.dev/docs/routing#pages\">SvelteKit Pages</a> that we will need.</p>\n<p>This is a list of svelte files on <code>admin/src/routes</code> for all of our pages.</p>\n<pre class=\"hljs\"><code>PS&gt;&gt; tree /f\n│   index.svelte\n│   __layout.svelte\n│\n├───blog\n│   │   create.svelte\n│   │   index.svelte\n│   │\n│   └───edit\n│           [slug].svelte\n│\n└───works\n    │   create.svelte\n    │   index.svelte\n    │\n    └───edit\n            [id].svelte\n</code></pre>\n<p><code>__layout.svelte</code> is a file that will contain our layout for every page. (You can read more on <a href=\"https://kit.svelte.dev/docs/layouts\">SvelteKit Doc</a>). So our navigation between 2 of content types will be here and it'll look like the image below.<br>\n<img src=\"https://i.imgur.com/zwgOfw5.png\" alt=\"overall\"><br>\nBoth <code>blog</code> and <code>works</code> routes are similar because they need to have these nested routes.</p>\n<ul>\n<li><code>index</code> is a page that will show us a list of our contents and some buttons to manage those contents. It'll look like the right side of a picture in <em>What I need in my CMS?</em> section.<br>\n<img src=\"https://i.imgur.com/m4qcIlX.png\" alt=\"data table\"></li>\n<li><code>create</code> and <code>edit/[some identifier]</code> is a page that will show us what information we need to provide to that content type. It'll look like the picture in <em>What I need in my CMS?</em> section too. <img src=\"https://i.imgur.com/dtAOtrc.png\" alt=\"create\"></li>\n</ul>\n<p><strong>Implementation</strong><br>\nFirst,  <code>__layout.svelte</code> is a simple svelte component with a few SMUI components inside it, nothing interesting.<br>\n<br>\nNext, <code>index.svelte</code> will contain <a href=\"https://sveltematerialui.com/demo/data-table/\">SMUI Data Table</a> with data from our API by using <a href=\"https://kit.svelte.dev/docs/loading\">SvelteKit Loading</a> by below code (blog route example).</p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span> context=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Load</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sveltejs/kit&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">load</span>: <span class=\"hljs-title class_\">Load</span> = <span class=\"hljs-keyword\">async</span> ({ fetch }) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/post&#x27;</span>);\n\t\t<span class=\"hljs-keyword\">const</span> posts = (<span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>[];\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">props</span>: { posts } };\n\t};\n&lt;/script&gt;\n</code></pre>\n<p>Last, let's look at how I implement <code>create.svelte</code> and <code>edit/[slug].svelte</code> of blog route. Both of these pages will contain the same component <code>Blogcard</code> that will has properties of <code>type Blog</code>. <code>Blogcard</code> will provide us with data visualization and input forms.<br>\n<br>\nSo in <code>create.svelte</code>, we will have an empty <code>Blogcard</code> that we need to fill the forms and we can save those data by fetching our API (below code).</p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> { goto } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$app/navigation&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">BlogContent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Blogcard</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/components/blogcard.svelte&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleSave</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">event: <span class=\"hljs-built_in\">any</span></span>) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> blogpost = event.<span class=\"hljs-property\">detail</span>.<span class=\"hljs-property\">blogpost</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BlogContent</span>;\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/post&#x27;</span>, {\n\t\t\t<span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n\t\t\t<span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(blogpost)\n\t\t});\n\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">200</span>) {\n\t\t\t<span class=\"hljs-title function_\">goto</span>(<span class=\"hljs-string\">`/blog/edit/<span class=\"hljs-subst\">${event.detail.slug}</span>`</span>);\n\t\t}\n\t};\n&lt;/script&gt;\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Blogcard</span> <span class=\"hljs-attr\">on:save</span>=<span class=\"hljs-string\">{handleSave}</span> /&gt;</span></span>\n</code></pre>\n<p>Did you see something interesting? On <code>&lt;Blogcard on:save={handleSave} /&gt;</code>, what is <code>on:save={handleSave}</code>?. It's a <a href=\"https://svelte.dev/tutorial/event-forwarding\">Svelte Event Forwarding</a> mechanism. By using the below code on <code>Blogcard</code> component, we can handle <code>Blogcard</code> save button behavior on an upper component.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title function_\">createEventDispatcher</span>();\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSave</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) =&gt; {\n\t<span class=\"hljs-keyword\">if</span> (filled) { <span class=\"hljs-comment\">// check if forms if filled</span>\n\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">blogpost</span>: <span class=\"hljs-title class_\">BlogContent</span> = {\n\t\t\ttitle,\n\t\t\tdescription,\n\t\t\tcontent\n\t\t};\n\t\t<span class=\"hljs-title function_\">dispatch</span>(<span class=\"hljs-string\">&#x27;save&#x27;</span>, { blogpost, slug }); <span class=\"hljs-comment\">// dispatch event data</span>\n\t}\n};\n</code></pre>\n<p>Now, in <code>edit/[slug].svelte</code> there is significant only one changes from <code>create.svelte</code>.<br>\n<br>\nWe are using square brackets on Svelte component file. This is a SvelteKit dynamic parameters.</p>\n<blockquote>\n<p>From <a href=\"https://kit.svelte.dev/docs/routing#pages\">SvelteKit Doc</a><br>\nDynamic parameters are encoded using <code>[brackets]</code>. For example, a blog post might be defined by <code>src/routes/blog/[slug].svelte</code>. These parameters can be accessed in a <a href=\"https://kit.svelte.dev/docs/loading#input-params\"><code>load</code></a> function or via the <a href=\"https://kit.svelte.dev/docs/modules#$app-stores\"><code>page</code></a> store.</p>\n</blockquote>\n<p>Now we can use dynamic parameters to fetch our blog content that we want to edit and show it on <code>Blogcard</code> by providing its properties with fetched blog content. We can use <a href=\"https://svelte.dev/tutorial/spread-props\">Svelte Spread Props</a> for more compact code too.<br>\n<br>\n<em>Above paragraph in code.</em></p>\n<pre class=\"hljs\"><code>&lt;script lang=<span class=\"hljs-string\">&quot;ts&quot;</span> context=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Load</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sveltejs/kit&#x27;</span>;\n\t<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span>, <span class=\"hljs-title class_\">BlogContent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;$lib/blog&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">load</span>: <span class=\"hljs-title class_\">Load</span> = <span class=\"hljs-keyword\">async</span> ({ fetch, params }) =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/post?slug=<span class=\"hljs-subst\">${params.slug}</span>`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> post = (<span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Blog</span>;\n\t\t<span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">props</span>: { post } };\n\t};\n&lt;/script&gt;\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ts&quot;</span>&gt;</span><span class=\"language-javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">post</span>: <span class=\"hljs-title class_\">Blog</span>;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Blogcard</span> {<span class=\"hljs-attr\">...post</span>} <span class=\"hljs-attr\">on:save</span>=<span class=\"hljs-string\">{handleSave}</span> /&gt;</span></span>\n</code></pre>\n<p>For <code>works</code> route the implementation is the same as <code>blog</code> route. You can view all source code on <a href=\"https://github.com/RiwEZ/TanatBlog\">TanatBlog</a> repo.</p>\n<h3>Conclusion</h3>\n<p>Yeyyy! I finished creating my own CMS for my blog. We have learned how to create basic <a href=\"https://kit.svelte.dev/\">SvelteKit</a> web-app with <a href=\"https://sveltematerialui.com/\">SMUI</a> and <a href=\"https://tailwindcss.com/\">tailwindcss</a> and using <a href=\"https://jestjs.io/\">Jest</a> to test backend too. If you have any question please comment below or <a href=\"/TanatBlog/contact\">contact me</a>, and be sure to check <a href=\"https://github.com/RiwEZ/TanatBlog\">TanatBlog</a> repo.</p>\n<blockquote>\n<p>This project was fun, but it took way too many times for me 😅. Hope this blog will help others do similar project faster!!!</p>\n</blockquote>\n","slug":"changing-from-strapi-to-my-owm-cms","createdAt":"2022-06-03T12:12:26.069Z","updatedAt":"2022-06-03T12:26:34.917Z"}